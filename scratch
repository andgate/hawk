-- Use ADTs with objects instead of records
-- Object access/update syntax in language
-- Object construction
-- Construction on stack/heap requires proof!

-- Intuitionistic Context
data Gamma
  = Gamma
  | GammaCons ITerm IType Gamma

-- Linear Context
data Delta
  = Delta
  | DeltaCons LTerm LType Delta  

data Var = Var String

type IType = ITerm

data ITerm 
  = IType
  | IVar Var
  | IUnit
  | ISigma (Var, IType) IType
  | IPi (Var, IType) IType
  | IPair ITerm ITerm
  | IFst ITerm
  | ISnd ITerm
  | ILam Var ITerm
  | IApp ITerm ITerm

  | IL LTerm -- Go linear

  -- <A>
  | ILinear LType
  | IPtr
  | IType ITerm IType


data LType
  = LTUnit
  | LTPair LType LType       -- Tensor product
  | LTLoli LType LType

  -- ( e : X | A e )
  | LT_I (Var, IType) LType  -- Basically a linear sigma

  -- L A
  -- Linear computation monad
  -- Is T in paper
  | LT_L LType
  
  -- Cap(e, X)
  -- Linear capabilities
  | LTCap ITerm IType


data LTerm
  = LVar Var
  | LUnit
  | ILam Var ITerm
  | IApp ITerm ITerm
  | LLet Var LTerm LTerm
  | LI ITerm
  | LRun ITerm
  | LType LType

-- Memory management!  
-- free : (x : Ptr) -> <Cap x X -o L I>
-- alloc : <L (x : Ptr | Cap x t)>


foo y =
  x = bar y
  x := 7
  baz x  -- Last stmt must be an expression...

Translates to...

foo : Foo -> Bar
foo y =
  let x = bar y
      x := 7
  in baz x
