type Array(x) {
  Array(data: *x, size: I32, cap: I32);
}

Array(): data(Null), size(0)
{ /* empty */ }

Array ( other: (Const Ref Array)(x) )
  : data(new x[other.size])
  , size(other.size)
{
  // we can use x as the type constructor
  // New will look at x and determine its type.
  // Since x is polymorphic, the type won't be
  // determined until monomorphization.
  data(new x[other.size]);
  size(other.size);

  for(int i = 0; i < size; ++i)
  {
    data[i] = other.data[i];
  }
}

Array ( initialSize: I32 )
  : data(new x[initialSize])
  | size(initialSize)
{
  for (int i = 0; i < initialSize; ++i)
    data[i] = 0;
}

Array ( other: (RVal Array)(x) )
{
  data(other.data);
  size(other.size);

  other.data = null;
  othe.rsize = 0;
}

Array ( data: Ptr(x), size: Const+Ref(I32) )
  : data(null), size(size)
{
  for (i = 0; i < size; ++i)
  {
    this.data[i] = data[i];
  }
}

~Array()
{
  delete(data, size);
}

append<x>(array: Array(x), elem: x)
{
  if (array.length >= array.capacity)
     array.resize(capacity*2);

  with (array) {
    data[size] = x;
    ++size;
  }
}


class HasLength(f) {
  getLength(item): const &f -> I32;
}


impl HasLength<x>(Array(x))
{
  getLength(arr) : const &Array x -> I32
  {
    return arr.size;
  }
}


doStuff<HasLength a>(thingy: a) {
  // do some stuff
  let len = getLength(thingy);
  // do more stuff
  return;
}

main(): Int
{
  let a(): Arr(I32);
  doStuff(a);
  return 0;
}
