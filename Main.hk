type REF(a) = Const(Ref(a));

type Array(x : Type) {
  Array( data: Ptr(x)
       , size: I32
       , cap: I32
       );
}

Array()
  : data(Null)
  , size(0)
  , cap(0);
{}


Array ( other: REF(Array(x)) )
  : data(new x[other.size])
  , size(other.size)
{
  for(int i = 0; i < size; ++i)
  {
    data[i] = other.data[i];
  }
}

Array ( initialSize: I32 )
  : data(new x[initialSize])
  | size(initialSize)
{
  for (int i = 0; i < initialSize; ++i)
    data[i] = 0;
}

Array ( other: RVal(Array(x)) )
{
  data(other.data);
  size(other.size);

  other.data = null;
  othe.rsize = 0;
}

Array ( data: REF(x), size: Const(I32) )
  : data(new x[size]), size(size), capacity(size)
{
  for (i = 0; i < size; ++i)
  {
    this.data[i] = data[i];
  }
}

~Array()
{
  delete(data, size);
}

append<x>(array: Array(x), elem: x)
{
  if (array.length >= array.capacity)
     array.resize(capacity*2);

  with (array) {
    data[size] = x;
    ++size;
  }
}


class GetLength(f) {
  getLength(item: REF(f)): I32;
}

class SetLength(f) {
  setLength(thing: Ref(f)): Ref(f); 
}


impl GetLength<x>(Array(x))
{
  length(arr: REF(Array(x)) -> I32
  {
    return arr.size;
  }
}

impl SetLength<x>(Array(x))
{
  length(arr: Ref(Array(x), newLength: Const(I32)): Ref(Array(x))
  {
    // Newer allows arrays to resize intelligently.
    // Basically accepts a pointer and reallocs.
    // This will result in a new array.
    // Any given ptr might be invalidated.
    // If the resize is efficient, the array boundary will
    // simply grow.
    newer arr.data [newLength];
    arr.size = newLength;
    arr.cap = newLength;
  }
}

class Sortable(f : Type -> Type)
{
  sort<a>( container: Ref(f(a)) ): Ref(f(a)) -> Ref(f(a)); 
}

impl Sortable<x>(Array(x))
{
  sort(container) // optional : Ref(Array(x))
  {
    /* Implement quicksort or something */
  }
}


doStuff<HasLength(a)>(thingy: a) {
  // do some stuff
  let len = getLength(thingy);
  // do more stuff
  return;
}


// Algebra!

class Category(c)
{
  compose(a: c, b: c): c;
}

class Semigroup(m)
{
  mappend(a: Const(m), b: Const(m)): m;
}

class Monoid<Semigroup m>(m)
{
  mempty(): m;
}

class Functor(f: Type -> Type)
{
  fmap<a,b>(f: REF(a) -> b, x: REF(f( Const(a) )) ): f(b);
}


// We can have a maybe type

type Maybe(x)
{
  Nothing();
  Just(x);
}


// And we can write Maybe to act algebraically.
impl Semigroup<Semigroup x>(Maybe(x))
{
  mappend(a, b)
  {
    case(a, b) {
      Nothing(), _ {
        return b;
      Just(_), Nothing() {
        return a;
      }
      Just(x), Just(y) {
        return Just(x<>y);
      }
    }
  }
}

impl Monoid<Monoid x>(Maybe(x))
{
  mempty() { return Just(mempty()); }
}


// Functors are easily expressible
impl Functor(Maybe(x))
{
  fmap(f, m)
  {
    case(m) {
      Nothing()
        return Nothing();
      Just(x)
        return Just(f(x)); 
    }
  }
}

/* Simple main function */
main(): I32
{
  let foo([2, 3, 100, 4, 7], 5): Arr(I32);
  doStuff(foo);

  foo.sort();
  return 0;
}
