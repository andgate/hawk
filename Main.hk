type REF(a) = Const(Ref(a));

type Array(x : Type) {
  Array( data: Ptr(x)
       , size: I32
       , cap: I32
       );
}

Array()
  : data(Null)
  , size(0)
  , cap(0);
{}


Array ( other: REF(Array(x)) )
  : data(new x[other.size])
  , size(other.size)
{
  for(int i = 0; i < size; ++i)
  {
    data[i] = other.data[i];
  }
}

Array ( initialSize: I32 )
  : data(new x[initialSize])
  | size(initialSize)
{
  for (int i = 0; i < initialSize; ++i)
    data[i] = 0;
}

Array ( other: RVal(Array(x)) )
{
  data(other.data);
  size(other.size);

  other.data = null;
  othe.rsize = 0;
}

Array ( data: REF(x), size: Const(I32) )
  : data(new x[size]), size(size), capacity(size)
{
  for (i = 0; i < size; ++i)
  {
    this.data[i] = data[i];
  }
}

~Array()
{
  delete(data, size);
}

append<x>(array: Array(x), elem: x)
{
  if (array.length >= array.capacity)
     array.resize(capacity*2);

  with (array) {
    data[size] = x;
    ++size;
  }
}


class GetLength(f) {
  getLength(item: REF(f)): I32;
}

class SetLength(f) {
  setLength(thing: Ref(f)): Ref(f); 
}


impl GetLength<x>(Array(x))
{
  length(arr: REF(Array(x)) -> I32
  {
    return arr.size;
  }
}

impl SetLength<x>(Array(x))
{
  length(arr: Ref(Array(x), newLength: Const(I32)): Ref(Array(x))
  {
    // Newer allows arrays to resize intelligently.
    // Basically accepts a pointer and reallocs.
    // This will result in a new array.
    // Any given ptr might be invalidated.
    // If the resize is efficient, the array boundary will
    // simply grow.
    newer arr.data [newLength];
    arr.size = newLength;
    arr.cap = newLength;
  }
}

class Sortable(f : Type -> Type)
{
  sort<a>( container: Ref(f(a)) ): Ref(f(a)) -> Ref(f(a)); 
}

impl Sortable<x>(Array(x))
{
  sort(container) // optional : Ref(Array(x))
  {
    /* Implement quicksort or something */
  }
}


doStuff<HasLength a>(thingy: a) {
  // do some stuff
  let len = getLength(thingy);
  // do more stuff
  return;
}

main(): Int
{
  let foo([1, 2, 3], 3): Arr(I32);
  doStuff(foo);
  return 0;
}
