{-# LANGUAGE  DeriveGeneric
            , FlexibleContexts
            , TypeFamilies
            , OverloadedStrings
            , LambdaCase
            , TemplateHaskell
  #-}
module Language.Hawk.Syntax.Term where

import Control.Arrow (first, second)
import Data.List.NonEmpty (NonEmpty)
import Data.Monoid
import Data.Set (Set)
import Data.Text (Text)
import Data.Text.Prettyprint.Doc

import Language.Hawk.Syntax.Definition
import Language.Hawk.Syntax.Literal
import Language.Hawk.Syntax.Location
import Language.Hawk.Syntax.Name
import Language.Hawk.Syntax.Pattern
import Language.Hawk.Syntax.Prim
import Language.Hawk.Syntax.Subterm

import qualified Data.List.NonEmpty             as NE
import qualified Data.Set                       as Set


-- -----------------------------------------------------------------------------
-- | Terms

type Type = Term

-- Dependent Term
data Term v
  = TVar  v
  | TLit  Lit
  
  | TCon  Text
  | TPrim PrimInstr (Term v) (Term v)
  
  | TApp  (Term v) (Term v)
  | TLam  (Pat (Type v) v) (Term v)

  | TPi   (Pat (Type v) v) (Term v)   -- Regular pi, or arrow
  | TLPi  (Pat (Type v) v) (Term v)   -- Linear pi, or lolipop
  
  | TLet  (NonEmpty (Def (Term v))) (Term v)
  | TCase  (Term v) [(Pat (Term v) v, Term v)]
  
  | TDup  v
  | TFree [v] (Term v)

  -- Annotations
  | TAnnot (Term v) (Type v)
  | TSub   Subterm (Term v)
  | TLoc   Loc (Term v)
  | TParen (Term v)
  | TWild
  deriving(Show)

-- -----------------------------------------------------------------------------
-- | Helpers

pis :: [Pat (Type v) v] -> Term v -> Term v
pis ps t = foldr TPi t ps


-- -----------------------------------------------------------------------------
-- | Instances

instance {-# OVERLAPS #-} Locatable (Term v) where
  locOf = \case
    -- Check the upper annotations for 
    TAnnot e t -> locOf e
      -- (Since this had no TLoc, then the type is autogenerated, so it can be ignored.)
    TSub _ e -> locOf e
    TLoc l _  -> l
    -- Ignores parens and others like lambda
    _     -> error "No location found"

-- -----------------------------------------------------------------------------
-- | Pretty Instances

instance (Pretty v) => Pretty (Term v) where
    pretty = \case
      TVar n      -> pretty n
      TLit l      -> pretty l
      
      TCon n      -> pretty n
      TPrim i a b -> pretty i <+> pretty a <+> pretty b
      
      TApp e1 e2  -> pretty e1 <+> pretty e2
      TLam p e    ->
          "\\" <+> pretty p
            <+> vsep [ "."
                     , indent 2 (pretty e)
                     ]

      TPi p t    ->
          parens (pretty p)
            <+> "->"
            <+> pretty t

      TLPi p t   ->
          parens (pretty p)
            <+> "->"
            <+> pretty t
      
      TLet xs e ->
        vsep  [ "let"
              , indent 2 ( vsep $ pretty <$> NE.toList xs )
              , "in" <> indent 2 (pretty e)
              ]
      
      TCase e brs ->
        vsep  [ "case" <+> pretty e <+> "of"
              , indent 2 $ vsep
                  [ pretty p <+> "->" <+> pretty br
                    | (p, br) <- brs
                  ]
              ]

      TDup e ->
        "dup" <+> pretty e

      TFree ns e ->
        "free" <+> hsep (pretty <$> ns)
               <+> "in"
               <+> pretty e


      TAnnot e t ->
        pretty e <+> ":" <+> pretty t
      
      TSub st e ->
        parens ( pretty e <+> "?" <+> pretty st )
      
      TLoc _ e  -> pretty e -- ignore location
      TParen t  -> parens $ pretty t
      TWild     -> "_"