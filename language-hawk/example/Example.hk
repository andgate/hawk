--module Example x ? Core.IO, Core.Math, Core.List x has

--|   Sample of a basic Hawk program.
  Hawk is similar in syntax to Haskell,
  but technically closer to C.
|--

--| Hawk is a purely functional langauge
  The definition of variables and functions is similar.
  In fact, Hawk treats variables as functions that take no arguments.
|--
a = #add 1 2


-- Declarations and types
-- Simple task that does things
black : Color
black =
  let red   <- Color3f 1.0 0 0    -- stack allocation by default
      blue  <- @Color3f 0 0 1.0   -- heap allocation with @
      green <- @Color3f 0 1.0 0   -- Stack allocated
      green = red + blue + green
      free red, blue               -- This will erase a heap value
  in green

    
--module _ : Import C where

showPerson : { first : Int, last : Int | a} -> Int
showPerson { x@first, y@last }:
  add x y


add : Int -> Int -> Int
mul : Int -> Int -> Int

add_ln : Int -> Int -> (Int, Int, Int)
mul_ln : Int -> Int -> (Int, Int, Int)


fact : Int -> Int
fact x =
  case x of
    0 -> 1
    1 -> 1
    x -> x * fact (x-1)


fact_ln : Int -> (Int, Int)
fact_ln 0 = (0, 1)
fact_ln 1 = (1, 1)
fact_ln a =
  let (a, _, a') = add_ln a (-1)
      (_, a') = fact_ln a'
      (a, _, a') = mul a a'
  in (a, a')






-- Type signatures declare the type of a variable
c : Int
c = 3

-- So variable 'c' has type 'Int'

d = 3

-- Type signature tests
foo : Int -> Int -> Int
bar : Int -o Int -o Int



-- 'foo' is a function that takes two Ints and evalutes to an Int.
-- We can define it like so...
foo x y =
  #div (#mul (#add x 2) y) 3


--|   You might notice the '#' on the operations.
    '#' prefix is for primitive instructions.
    These are builtin to the language. As Hawk
    becomes more advanced, the regular mathematical
    operators will replace them.
  |--


-- Let expressions introduce variables into an expression
five =
  let x = #add 2 2
      y = #sub 3 1
  in #add y z




-- Product type with record syntax
Vec3f :=
  V { x : Float
    , y : Float
    , z : Float
    }

-- Or without record syntax
Color :=
  Color Float Float Float

-- We can also do sum types
Maybe a := Nothing | Just a


--|
-- GADTs can be established with type
Exp a : * -> * where
  EVal : Int -> Exp
  EVar : String -> Exp
  EApp : Exp -> Exp -> Exp
  ELam : String -> Exp -> Exp
|--

-- Newtypes are an optimization
-- on data with only a single constructor
Box a := Box a


-- Type aliasing is allowed
Color = Vec3f
Optional a = Maybe a

-- Type aliasing can be pointfree
Optional = Maybe


-- Class definitions
class Functor f where
  fmap : (a -> b) -> f a -> f b

-- Class instances
Functor Box where
  fmap f (Box x) = Box (f x)

--|   This creates a record with one constructor, Color.
    My color has three field accessors red, green, and blue.
    These are functions that when used on a variable of type
    "Color", will evalute to the information in that field.
  |--


--|
-- Here is a function that produces a new 
-- color with the values inverted
invert : Color -> Color
invert c =
  let r' = #fsub 1.0 (red c)
      g' = #fsub 1.0 (green c)
      b' = #fsub 1.0 (blue c)
  in Color r' g' b'

  |--


--|   This is a good opportunity to explain Hawk's memory model.
    Hawk is a linear typed programming language. That means every
    variable in a definition must be used exactly once and only once.
    You can think of Hawk functions as hungry functions, that will eat
    whatever values you pass into them so other functions cannot have them.

      However, 'invert' clearly doesn't follow this rule! But the program
    compiles and runs! What is going on?

      To cope with a linear typing model, the Hawk language provides two
    expressions "dup x" and "drop x in e". These allow Hawk to have a linear
    memory model, but also have specific points where memory duplication and
    deallocation can occur.

      At some point, the compiler will insert dup and drop where neccessary.
    So what actually happens in invert is that 'c' is copied twice, and finally
    used on the last structure accessor. The compiler turns 'invert' into...
    
      invert c =
        let r' = #subf 1.0 (red (dup c))
            g' = #subf 1.0 (green (dup c))
            b' = #subf 1.0 (blue c)
        in Color r' g' b'

    Notice the dup? And for an example of a function that destroys data...
    
      destroy x y = x

    Which is transformed into...
    
      destroy x y = drop y in x

      As Hawk becomes more advanced, it will be possible to optimize this
    memory model to reduce copying and destruction under the hood, by mutating
    values when possible, instead of destroying them and producing new ones.
      It should also be possible to optimize away the linear typing rules for values
    that live on stack.
      Hawk may also provide alternative record accessors, that will duplicate the
    field and pass out the record unconsumed for reuse. This can also be inferred.
      And while the potential for optimization is quite large, programs written that
    follow the law of linear typing (use all variables exactly once) will run quickly
    and even be competetive with C. And programmers can be confident about when
    memory allocation and deallocation.
    
|--