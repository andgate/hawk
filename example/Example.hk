/* Sample of a basic Hawk program.
   Hawk is similar in syntax to Haskell,
   but technically closer to C.
*/
mod Example


// Import items, place them under a "C" namespace
-> Core.(IO.(printLn readLn Stdout Stdin)
          Math.Trig.(sin cos tan)
        ) @ C

// Import Core, except for Control.Moand and Data.Array
// Require minimal namespace qualification.
=> Core.(\ Control.Monad Data.Array )


// var introduces variables
// Variables can be assigned to the result of an expression
var a = 1 + 2

// Or bound to the result of a block
var b:
  return 1 + 2

// sig can be used to declare the type of a var
sig c ? Int
var c = 3

// Or the var's expression can be annotated with a type sig
var d = 3 ? Int

// sig is used to introduce type signatures
sig foo ? Int -> Int -> Int

// vow is used for contract programming
vow foo val val
// fun is used to introduce a function
// This is a function bound to an expression
fun foo x y =
  #div (#mul (#add x 2) y) 3 // '#' prefix is for primitive instructions


// This is a function bound to an expression
fun five:
  var z = #add 2 3
  return z



// Type alias, type system will treat these as interchangable
type Inch = I32

// New types are not treated as interchangable.
newtype Size = I32

// Introduce data structures, consisting of only variables
data MyColor:
  r ? F32
  g ? F32
  b ? F32


data OtherColor:
  red ? F32
  green ? F32
  blue ? F32
  alpha ? F32

// Type classes define interfaces
class HasRGB a:
  max ? a -> F32

  getR ? a -> F32
  getG ? a -> F32
  getB ? a -> F32

  setR ? a -> F32 -> ()
  setG ? a -> F32 -> ()
  setB ? a -> F32 -> ()

// Type classes are then instanced for a specific datatype
inst HasRGB MyColor:
  max c = 255

  getR c = c.r
  getG c = c.g
  getB c = c.b

  setR c r = c.r = r
  setG c g = c.g = g
  setB c b = c.b = b


// Type classes are then instanced for a specific datatype
inst HasRGB OtherColor:
  max c = 1.0

  getR c = c.red
  getG c = c.green
  getB c = c.blue

  getR c r = c.red = r
  getG c g = c.green = g
  getB c b = c.blue = b


// Then we can define a function that works over ANY data with rgb
sig invertRgb ? HasRGB a => a -> ()
fun invertRgb c:
  c.setR (c.max - c.getR)
  c.setG (c.max - c.getG)
  c.setB (c.max - c.getB)
  // No return automatically returns '()', or unit.

// So, if there were multiple competing Color types from different libraries,
// it's trivial to write a function that applies to all of them.
// I didn't get into it, but the numeric values can be classified as well,
// so floats of different sizes could be supported as well.