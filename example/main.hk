/* Sample of a basic Hawk program.
   Hawk is similar in syntax to Haskell,
   but technically closer to C.
*/

-> IO

<x SizeT
SizeT = I32

<- Car(..) Color(..) Automobile(..) 

// Type operator's can only be constructed through a type def
(_!->!_) f a = f -> IO a  

// Record (aka struct)
Car:
  gas       ? I32
  max_speed ? I32

// Tagged Union (aka sum type)
Color:
  | Red I32
  | Green I32
  | Blue I32

 
// Algebraic syntax for sum type
ColorAlt:
  | Red ? I32 -> Color
  | Green ? I32 -> Color
  | Blue ? I32 -> Color

// Type class (aka interface, polymorphic record)
Automobile a :
  drive ? a -> IO ()
  paint ? a -> Color -> IO ()

// Instancing a typeclass
Automobile Car:
  drive car = do
    let out = toString max_speed
    print out

  paint car color =
    print
      $ "Car painted " +
      $ case color of
          Red x -> x + "% Red"
          Green x -> x + "% Green"
          Blue x -> x + "% Blue"


// TODO: Efficient Pattern matching
/*
fst (a,_)
  ? (a,b) -> a
  = a
*/

id
 ? a -> a
 = \ x -> x

// Creating variables, which are all mutable by default.
<- a b c
a ? I32 = 4
b = 2
c = 1 ? I32


// Main function and default entry point of all programs.
// An executable cannot compile without a main function.
main foo 
  ? IO ()
  :=
  // Create some cars
  let car_a ? Car = Car 12 124
      car_b ? Car = Car 19 103

  // Drive some cars
  drive car_a
  drive car_b // If drive mutated car_b, and error should be thrown.
  


<- if_then_else_ while_:_

(6r) if_then_else_ p a b
  ? Bool -> [Expr a] -> [Expr a] -> Q (Expr a)
  = undefined
      
while_:_ 
  ? Bool -> [Expr a] -> Q (Expr a)
  = undefined