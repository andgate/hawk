--module Core has


-- Primitive Types
-- Numeric: Bit, Nat, Int, Real
-- Text:    Char, String
-- Array:   [x]
-- Memory:  Box, Linear, Ref, IO

-- Primitive constructors
-- Box = heap value
-- Linear = read-once heap value
-- Ref = Pointer to some other address.
--   Cannot copy into, can only set the pointer to a value.


-- New memory model
--  Needs:
--    1)  A Single Constructor
--    2)  Magical unboxing algorithm
            - intelligently organizes data
              between heap and stack.
--
--  Mutable, touchable objects ARE HARD.
--  Category theory doesn't work well with them.
--  What if delete was like (expr ; names)

-- Need to import the following from C...
--   putStr()

foreign import ccall putStr : String -> ()

-- Optimizes to a single bit, for single bit if checks
Bool = True | False

-- Box allows for heap storage
Box a = Box { unbox : a }
Ref a = Ref { deref : a }

wrap : a -> Box a
free : Box a -> a

-- Linear heap storage. If it is copied, it is destroyed!
Linear a = Linear { consume : a }

-- Construct a constant region of memory
Freeze a = Freeze a

-- Classic functiional types
Maybe a = Nothing | Just a
Either a b = Left a | Right b


-- ----------------------------------
-- Category Laws
-- 1.  f . id  ==  f    (right identity)
-- 2.  id . f  ==  f    (left identity)
-- 3.  f . (g . h) == (f . g) . h   (associativity)
-------------------------------------

($) : (a -> b) 

class Category cat where
  id : cat a a
  (.) : cat 

Category (->) where
  id = \a -> a
  (.) g f a = g (f a) 


-------------------------------------
-- Functor Laws
-- 1.  fmap id  ==  id
-- 2.  fmap (f . g)  ==  fmap f . fmap g
-------------------------------------

-- Functor Class
class Functor f has
  fmap : (a -> b) -> f a -> f b


-- Functor Instances
Functor Box has
  fmap f (Box x) = Box (f x)
  
Functor Linear has
  fmap f (Linear x) = Linear (f x)

Functor Maybe has
  fmap f Nothing = Nothing
  fmap f (Just a) = Just (f a)

Functor Either a has
  fmap f e =
    case e of
      Left x -> Left x
      Right a -> Right a

Functor [a] has
  fmap f xs = do
    xs' <- Arr (size xs) []
    go <- ( \i -> xs'[i] = f xs[i]; go (i-1))  
    go (size xs)
    xs'


-- Applicative Class
class Functor f => Applicative f has
  pure : a -> f a
  (<*>) : f (a -> b) -> f a -> f b

-- Applicative Instances

Applicative Box has
  pure a = Box a
  (<*>) (Box f) m = fmap f m

Applicative Linear has
  pure a = Linear a
  (<*>) (Linear f) m = fmap f m
  
Applicative Maybe has
  pure a = Just a

  (<*>) (Just f) m = fmap f m
  (<*>) Nothing _  = Nothing
  
Applicative Either e where
  pure a = Right a
  
  (<*>) (Right f) m = fmap f m
  (<*>) (Left e)  _ = Left e


-- Monad Class
class Applicative m => Monad m a has
  (>>=) : m a -> (a -> m b) -> m b

  (>>) : m a -> m b -> m b
  (>>) m k = m >>= \_ -> k
  
  return : a -> m a
  return = pure


-- Monad Instances
Monad Box has
  (Box x) >>= k = k x

Monad Linear has
  (Linear x) >>= k = k x
  
Monad Maybe has
  (Just x) >>= k = k x
  Nothing >>= _ = Nothing

Monad Either e has
  (Left e) >>= k = Left e
  (Right x) >>= k = k x
  
  
-- Graph stuff

Rep
  = AdjecencyList
  | EdgeList
  | Matrix
  
IntGraph = IntGraph { edges : [[Int]] }

class Graph g has
  size : g -> Int
  bfs : g -> Int -> ([Int], [Int], [Int])
  
  
Graph IntGraph has
  size g = size . edges $ g
  bfs g s = do
    par <- Array (size g) : [Int]
    dist <- Array (size g) : [Int]
    q <- Array (size g) : [Int]
    
     
    
    
    
    return ([], [], [])
    
  


-- IO

readFile : String -> IO String
write
